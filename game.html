<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fishing Hook Game</title>
  <style>
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #1c2733;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      color: #f5f5f5;
    }

    .game-wrapper {
      text-align: center;
    }

    canvas {
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      background: linear-gradient(#87ceeb 0%, #87ceeb 35%, #004c6d 35%, #002c3a 100%);
      display: block;
      margin: 0 auto 10px;
    }

    .info {
      font-size: 14px;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div class="info">
      The boat moves back and forth on its own and gets faster as you play.<br>
      Raise/lower the hook with <strong>↑</strong> and <strong>↓</strong>.<br>
      Catch the fish before it reaches the other side or it's <strong>game over</strong>.<br>
      Press <strong>R</strong> to restart.
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;
    const WATER_LINE_Y = 175;

    // Boat sits on the water line and moves automatically
    const boat = {
      width: 90,
      height: 24,
      x: WIDTH / 2,
      y: WATER_LINE_Y - 24, // bottom at waterline
      baseSpeed: 160,       // base horizontal speed
      dirX: 1               // current direction: 1 = right, -1 = left
    };

    const hook = {
      width: 14,
      height: 20,
      lineLength: 150,
      minLength: 20,
      maxLength: 0 // set below
    };

    // Hook should be able to reach almost to the bottom
    hook.maxLength = HEIGHT - WATER_LINE_Y - hook.height - 5;

    let fishes = []; // at most one fish
    let keys = {
      up: false,
      down: false
    };

    let score = 0;
    let lastTime = 0;
    let gameOver = false;

    const lineSpeed = 260; // pixels/s for hook movement

    function randRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function spawnFish() {
      if (gameOver) return;

      // Speed and wiggle scale with score
      const difficulty = 1 + score * 0.15;

      const side = Math.random() < 0.5 ? 0 : 1; // 0 = from left, 1 = from right
      const baseY = randRange(WATER_LINE_Y + 50, HEIGHT - 80);

      const fishWidth = randRange(40, 60);
      const fishHeight = 22;

      const baseMinSpeedX = 80;
      const baseMaxSpeedX = 130;
      let x, speedX;

      if (side === 0) {
        x = -fishWidth - 10; // off left
        speedX = randRange(baseMinSpeedX, baseMaxSpeedX) * difficulty;
      } else {
        x = WIDTH + 10; // off right
        speedX = -randRange(baseMinSpeedX, baseMaxSpeedX) * difficulty;
      }

      const amplitude = randRange(20, 45); // vertical wiggle
      const angularSpeed = randRange(2, 4) * (0.7 + 0.3 * difficulty); // radians/sec
      const phase = Math.random() * Math.PI * 2;

      fishes = [
        {
          x,
          y: baseY,
          baseY,
          width: fishWidth,
          height: fishHeight,
          speedX,
          amplitude,
          phase,
          angularSpeed,
          colorShift: Math.random(),
          startingSide: side // Remember where it came from
        }
      ];
    }

    function resetGame() {
      score = 0;
      lastTime = 0;
      gameOver = false;
      fishes = [];
      boat.x = WIDTH / 2;
      boat.dirX = 1;
      hook.lineLength = 150;
      spawnFish();
    }

    // Input handling
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp") keys.up = true;
      if (e.key === "ArrowDown") keys.down = true;

      if (e.key === "r" || e.key === "R") {
        resetGame();
      }
    });

    window.addEventListener("keyup", (e) => {
      if (e.key === "ArrowUp") keys.up = false;
      if (e.key === "ArrowDown") keys.down = false;
    });

    function update(deltaTime) {
      if (gameOver) return;

      // Boat auto-movement: speed increases with score
      const boatSpeed = boat.baseSpeed * (1 + score * 0.12);
      boat.x += boat.dirX * boatSpeed * deltaTime;

      const halfBoat = boat.width / 2;
      if (boat.x < halfBoat) {
        boat.x = halfBoat;
        boat.dirX = 1; // bounce right
      }
      if (boat.x > WIDTH - halfBoat) {
        boat.x = WIDTH - halfBoat;
        boat.dirX = -1; // bounce left
      }

      // Move hook up/down (change line length)
      let lineDir = 0;
      if (keys.up) lineDir -= 1;
      if (keys.down) lineDir += 1;
      hook.lineLength += lineDir * lineSpeed * deltaTime;

      if (hook.lineLength < hook.minLength) hook.lineLength = hook.minLength;
      if (hook.lineLength > hook.maxLength) hook.lineLength = hook.maxLength;

      // Hook position
      const hookX = boat.x - hook.width / 2;
      const hookBaseY = WATER_LINE_Y; // line starts at water surface
      const hookY = hookBaseY + hook.lineLength;

      // Ensure a fish exists
      if (fishes.length === 0) {
        spawnFish();
      }

      for (let i = 0; i < fishes.length; i++) {
        const f = fishes[i];

        // Horizontal motion
        f.x += f.speedX * deltaTime;

        // Wavy / circular-like vertical motion
        f.phase += f.angularSpeed * deltaTime;
        f.y = f.baseY + f.amplitude * Math.sin(f.phase);

        // Keep fish inside reasonable vertical bounds
        const minY = WATER_LINE_Y + 30;
        const maxY = HEIGHT - 50;
        if (f.y < minY) f.y = minY;
        if (f.y + f.height > maxY) f.y = maxY - f.height;

        // Game over if fish reaches opposite side
        if (f.startingSide === 0 && f.x >= WIDTH) {
          // started on left, reached right
          gameOver = true;
        }
        if (f.startingSide === 1 && f.x + f.width <= 0) {
          // started on right, reached left
          gameOver = true;
        }

        // Collision with hook (AABB)
        const fishLeft = f.x;
        const fishRight = f.x + f.width;
        const fishTop = f.y;
        const fishBottom = f.y + f.height;

        const hookLeft = hookX;
        const hookRight = hookX + hook.width;
        const hookTop = hookY;
        const hookBottom = hookY + hook.height;

        const collided =
          fishLeft < hookRight &&
          fishRight > hookLeft &&
          fishTop < hookBottom &&
          fishBottom > hookTop;

        if (collided && !gameOver) {
          score++;
          fishes.splice(i, 1); // remove fish; new one will spawn next frame
          break;
        }
      }
    }

    function drawBackground() {
      // Water surface line
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, WATER_LINE_Y);
      ctx.lineTo(WIDTH, WATER_LINE_Y);
      ctx.lineWidth = 3;
      ctx.strokeStyle = "rgba(255,255,255,0.7)";
      ctx.stroke();
      ctx.restore();

      // Waves
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.2)";
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 4; i++) {
        const y = WATER_LINE_Y + 20 + i * 22;
        ctx.beginPath();
        for (let x = 0; x <= WIDTH; x += 40) {
          ctx.moveTo(x, y);
          ctx.quadraticCurveTo(x + 10, y - 4, x + 20, y);
          ctx.quadraticCurveTo(x + 30, y + 4, x + 40, y);
        }
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawBoatAndHook() {
      const hullY = boat.y;
      const hullHeight = boat.height;
      const hullWidth = boat.width;

      ctx.save();
      ctx.translate(boat.x, hullY);

      // Boat hull
      ctx.beginPath();
      ctx.moveTo(-hullWidth / 2, hullHeight / 2);
      ctx.lineTo(hullWidth / 2, hullHeight / 2);
      ctx.lineTo(hullWidth / 2 - 15, hullHeight);
      ctx.lineTo(-hullWidth / 2 + 15, hullHeight);
      ctx.closePath();
      ctx.fillStyle = "#8b4513";
      ctx.fill();
      ctx.strokeStyle = "#5c2f0c";
      ctx.stroke();

      // Boat top/cabin
      ctx.fillStyle = "#f4f4f4";
      ctx.fillRect(-hullWidth / 4, -hullHeight / 2, hullWidth / 2, hullHeight / 1.3);

      // Mast
      ctx.beginPath();
      ctx.moveTo(0, -hullHeight / 2);
      ctx.lineTo(0, -hullHeight - 25);
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#dcdcdc";
      ctx.stroke();

      // Flag
      ctx.beginPath();
      ctx.moveTo(0, -hullHeight - 25);
      ctx.lineTo(20, -hullHeight - 20);
      ctx.lineTo(0, -hullHeight - 15);
      ctx.closePath();
      ctx.fillStyle = "#ffcc00";
      ctx.fill();

      ctx.restore();

      // Draw fishing line & hook
      const hookCenterX = boat.x;
      const startY = WATER_LINE_Y; // water surface
      const endY = startY + hook.lineLength;

      // Fishing line
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(hookCenterX, startY);
      ctx.lineTo(hookCenterX, endY);
      ctx.strokeStyle = "rgba(230,230,230,0.9)";
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.restore();

      // Hook rectangle
      const hookRectX = hookCenterX - hook.width / 2;
      const hookRectY = endY;

      ctx.save();
      ctx.fillStyle = "#cccccc";
      ctx.fillRect(hookRectX, hookRectY, hook.width, hook.height);

      // Hook curve
      ctx.beginPath();
      const radius = hook.width / 2;
      ctx.arc(hookCenterX, hookRectY + hook.height, radius, 0, Math.PI, true);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#dddddd";
      ctx.stroke();
      ctx.restore();
    }

    function drawFish(fish) {
      ctx.save();
      ctx.translate(fish.x + fish.width / 2, fish.y + fish.height / 2);

      const baseColor = 160 + fish.colorShift * 60;
      ctx.fillStyle = `hsl(${baseColor}, 70%, 50%)`;
      ctx.strokeStyle = "rgba(0,0,0,0.4)";
      ctx.lineWidth = 1.2;

      // Body
      ctx.beginPath();
      ctx.ellipse(0, 0, fish.width / 2, fish.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Tail (depends on direction)
      const tailWidth = fish.width / 3;
      const tailHeight = fish.height;
      const direction = fish.speedX > 0 ? -1 : 1; // tail on trailing side

      ctx.beginPath();
      ctx.moveTo(direction * fish.width / 2, 0);
      ctx.lineTo(direction * (fish.width / 2 + tailWidth), -tailHeight / 2);
      ctx.lineTo(direction * (fish.width / 2 + tailWidth), tailHeight / 2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Eye
      ctx.beginPath();
      const eyeX = -direction * fish.width / 4;
      ctx.arc(eyeX, -fish.height / 6, 3, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(eyeX, -fish.height / 6, 1.4, 0, Math.PI * 2);
      ctx.fillStyle = "#000000";
      ctx.fill();

      ctx.restore();
    }

    function drawHUD() {
      ctx.save();
      ctx.font = "18px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
      ctx.fillStyle = "#ffffff";
      ctx.textBaseline = "top";
      ctx.fillText(`Score: ${score}`, 16, 12);
      ctx.restore();

      if (gameOver) {
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.fillRect(WIDTH / 2 - 220, HEIGHT / 2 - 80, 440, 160);

        ctx.fillStyle = "#ffffff";
        ctx.font = "36px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Game Over", WIDTH / 2, HEIGHT / 2 - 10);

        ctx.font = "20px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
        ctx.fillText(`Final Score: ${score}`, WIDTH / 2, HEIGHT / 2 + 20);
        ctx.fillText(`Press "R" to play again`, WIDTH / 2, HEIGHT / 2 + 50);
        ctx.restore();
      }
    }

    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      update(deltaTime);
      drawBackground();
      drawBoatAndHook();
      fishes.forEach(drawFish);
      drawHUD();

      requestAnimationFrame(gameLoop);
    }

    // Start game
    resetGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>

